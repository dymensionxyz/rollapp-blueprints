# AI Gambling RollApp Indexer

This binary is an example of how to connect to AI Gambling smart contract and listen for its events. Run this package as a usual Go program without any arguments.

```bash
go run .
```

In the current implementation, the events are just printed in STDOUT, but it can be easily modified to store them in a database or any other storage. Feel free to modify the code to suit your needs.

## Configuration

The code has a config that allow to change the target smart contract.

```go
type IndexerConfig struct {
	ContractAddress string
	NodeEvmRpcUrl   string
	NodeRpcUrl      string
	WSEndpoint      string
}

func DefaultConfig() IndexerConfig {
	return IndexerConfig{
		ContractAddress: "0xADD60403BFc7e76C0670E835cAEb606569bc9ddE",
		NodeEvmRpcUrl:   "http://0.0.0.0:8545",
		NodeRpcUrl:      "http://127.0.0.1:26657",
		WSEndpoint:      "/websocket",
	}
}
```

## Available events

Here are the list of available events:
```solidity
 /**
 * @dev Structure to represent a bet. If bet exists, then it is active.
 * Active bet may or may not be resolved.
 * @param promptId The ID of the prompt associated with the bet.
 * @param amount The amount of the bet.
 * @param communityFee The community fee deducted from the bet.
 * @param guessedNumber The number guessed by the user.
 * @param correctNumber The correct number generated by the AI system.
 * @param persuasion The persuasion message sent to the AI system.
 * @param resolved Whether the bet has been resolved.
 * @param won Whether the bet was won.
 * @param canceled Whether the bet was canceled.
 */
struct Bet {
    uint64 promptId;
    uint256 amount;
    uint256 communityFee;
    uint256 guessedNumber;
    uint256 correctNumber;
    string persuasion;
    bool resolved;
    bool won;
    bool canceled;
}

event BetPlaced(address indexed user, Bet bet);
event BetResolved(address indexed user, Bet bet);
```

Events are located in [AIGambling.sol.go](AIGambling.sol.go) and represented as Go structures. The main processing happens in the `HandleEventLog` function. 

```go
// HandleEventLog is a callback function that processes the contract events.
// In the current implementation, the events are just printed in STDOUT, but
// it can be easily modified to store them in a database or any other storage.
func HandleEventLog(logger tmlog.Logger, contract *AIGambling) func(types.Log) error {
    return func(log types.Log) error {
    betPlaced, err := contract.ParseBetPlaced(log)
    if err == nil {
        // Here you can store the event in a database or any other storage
        logger.Info("Got BetPlaced!", "event", betPlaced)
        return nil
    }

    betResolved, err := contract.ParseBetResolved(log)
    if err == nil {
        // Here you can store the event in a database or any other storage
        logger.Info("Got BetResolved!", "event", betResolved)
        return nil
    }
    
    return fmt.Errorf("unknown event log: %v", log)}
}
```

### BetPlaced

```go
type AIGamblingBetPlaced struct {
    User common.Address
    Bet  AIGamblingBet
    Raw  types.Log // Blockchain specific contextual infos
}
```

Emitted when a bet is placed. The event contains the user address and the **initial** bet details.
  - `resolved`, `won`, and `canceled` are always `false`;
  - `correctNumber` is always `0`.

### BetResolved

```go
type AIGamblingBetResolved struct {
    User common.Address
    Bet  AIGamblingBet
    Raw  types.Log // Blockchain specific contextual infos
}
```

Emitted when a bet is resolved. The event contains the user address and the **resolved** bet details.
  - `resolved` is always `true`;
  - `won` is e set according to the bet outcome;
  - `canceled` is `true` if the bet result is not valid (currently, the user cannot manually cancel the bet);
  - `correctNumber` is the number generated by the AI system. `0` if the bet is canceled.

## Possible Metrics

- Number of bets placed
- Number of bets won
- Number of bets lost
- Total amount of bets placed
- Total amount of bets won
- Total amount of bets lost
- Total amount of community fees
- Total amount of user rewards
- Total amount of house rewards
- The most popular number guessed
- The most popular answer from the AI (maybe a bad metric to show publicly)
- Some interesting persuasion messages
- The most successful persuasion message
- The biggest lost bet (amount of coins)
- The biggest won bet (amount of coins)
- The biggest community fee paid
- Average bet amount
- Average win amount

Some statistics by the user. The user with:
- The most bets
- The most won bets (number of bets)
- The most lost bets (number of bets)
- The most community fees paid
- The most money won (amount of coins)
- The most money lost (amount of coins)
- The highest average bet amount
- The highest average win amount
- The highest average loss amount
- The highest win rate
- The highest loss rate

## HTTP API

_TBD_

- Get the house balance
- Get the user balance
- Get the user current bet
- Get the user bet history
- Get max bet amount
- Estimate the bet reward

## Useful commands

Deploy the AI Gambling contract to the local network. This will print the new contract address.
```bash
npx hardhat run ignition/gambling/deploy.js --network localhost
```

Deposit supply to the AI Gambling contract. Adjust the contract address in the script if needed.
```bash
npx hardhat run ignition/gambling/depositSupply.js --network localhost
```

Generate the ABI for the AI Gambling contract.
```bash
solc @openzeppelin/=$(pwd)/node_modules/@openzeppelin/ --abi contracts/AIGambling.sol -o build --overwrite
```

Generate the Go binding for the AI Gambling contract (ABI must be generated first).
```bash
abigen --abi build/AIGambling.abi --pkg main --type AIGambling --out stats/AIGambling.sol.go
```