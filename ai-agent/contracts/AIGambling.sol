// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {AIOracle} from "./AIOracle.sol";
import {House} from "./House.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title AIGambling
 * @dev A contract for placing bets and resolving them using an AI system.
 * Inherits from the House contract to manage balances and the AIOracle contract to interact with the AI.
 */
contract AIGambling is House {
    /**
     * @dev Structure to represent a bet. If bet exists, then it is active.
     * Active bet may or may not be resolved.
     * @param promptId The ID of the prompt associated with the bet.
     * @param amount The amount of the bet.
     * @param guessedNumber The number guessed by the user.
     * @param correctNumber The correct number generated by the AI system.
     * @param persuasion The persuasion message sent to the AI system.
     * @param resolved Whether the bet has been resolved.
     * @param won Whether the bet was won.
     * @param canceled Whether the bet was canceled.
     */
    struct Bet {
        uint64 promptId;
        uint256 amount;
        uint256 guessedNumber;
        uint256 correctNumber;
        string persuasion;
        bool resolved;
        bool won;
        bool canceled;
    }
    // Mapping to store active bets by user address
    mapping(address => Bet) public bets;
    // Mapping to store the history of bets by user address
    mapping(address => Bet[]) public history;

    event BetPlaced(address indexed user, Bet bet);
    event BetResolved(address indexed user, Bet bet, uint256 communityFee);

    // Instance of the AIOracle contract
    AIOracle private aiOracle;

    /**
     * @dev Structure to represent the game information.
     * @param houseSupply The total supply of the house.
     * @param houseActiveBalance The active balance of the house.
     * @param minBetAmount The minimum bet amount.
     * @param maxBetAmount The maximum bet amount.
     * @param maxBetAmountPercentage The maximum bet amount as a percentage of the house balance.
     */
    struct GameInfo {
        uint256 houseSupply;
        uint256 houseActiveBalance;
        uint256 minBetAmount;
        uint256 maxBetAmount;
        uint256 maxBetAmountPercentage;
    }

    // Constant prompt to be sent to the AI system
    string public constant PROMPT = "Generate a number between 1 and 10, inclusive";

    /**
     * @dev Constructor to initialize the contract with the initial owner and AIOracle address.
     * @param _initialOwner The address of the initial owner.
     * @param _aiOracle The address of the AIOracle contract.
     */
    constructor(address _initialOwner, address _aiOracle) House(_initialOwner) {
        require(_aiOracle != address(0), "Invalid AIOracle address");
        aiOracle = AIOracle(_aiOracle);
    }

    /**
     * @dev Function to place a bet. The user must send Ether with this transaction.
     * @param guessedNumber The number guessed by the user.
     * @param persuasion The persuasion message to be sent to the AI system. May be empty.
     */
    function placeBet(uint256 guessedNumber, string memory persuasion) external payable {
        require(bets[msg.sender].amount == 0 || bets[msg.sender].resolved, "Resolve your current bet first");
        require(msg.value >= minBetAmount, "Bet amount is too low");
        require(msg.value <= maxBetAmount(), "Bet amount is too high");

        string[] memory prompt;
        if (bytes(persuasion).length > 0) {
            // Put the reasoning before the prompt if it exists
            prompt = new string[](2);
            prompt[0] = persuasion;
            prompt[1] = PROMPT;
        } else {
            prompt = new string[](1);
            prompt[0] = PROMPT;
        }

        uint64 promptId = aiOracle.submitPrompt(prompt);

        Bet memory bet = Bet({
            promptId: promptId,
            amount: msg.value,
            guessedNumber: guessedNumber,
            correctNumber: 0,
            persuasion: persuasion,
            resolved: false,
            won: false,
            canceled: false
        });

        bets[msg.sender] = bet;

        emit BetPlaced(msg.sender, bet);
    }

    /**
     * @dev Function to resolve a bet. The user must call this function to resolve their bet.
     */
    function resolveBet() external {
        Bet storage bet = bets[msg.sender];
        require(!bet.resolved, "Bet already resolved");

        string memory correctNumberStr = aiOracle.getAnswer(bet.promptId);
        uint256 reward = 0;
        uint256 communityFee = 0;

        if (validateAIAnswer(correctNumberStr)) {
            // TODO: Use OpenZeppelin's Strings.parseUint256 method after v5.2.0 is released.
            bet.correctNumber = stringToUint(correctNumberStr);

            if (bet.guessedNumber == bet.correctNumber) {
                reward = estimateReward(bet.amount);
                communityFee = estimateCommunityFee(bet.amount);
                reward -= communityFee;
                bet.won = true;
                addBalance(msg.sender, reward);
                collectFee(communityFee);
            }
        } else {
            // Refund the bet amount if the AI system returned an invalid answer
            bet.canceled = true;
            addBalance(msg.sender, bet.amount);
        }

        bet.resolved = true;
        history[msg.sender].push(bet);

        emit BetResolved(msg.sender, bet, communityFee);
    }

    function validateAIAnswer(string memory answer) internal pure returns (bool) {
        if (bytes(answer).length == 0) {
            return false;
        }
        // Now we assume that the contract may only work with numbers from 1 to 10.
        if (bytes(answer).length > 2) {
            return false;
        }
        // We expect to see only digits in the answer.
        for (uint256 i = 0; i < bytes(answer).length; i++) {
            if (bytes(answer)[i] < 0x30 || bytes(answer)[i] > 0x39) {
                return false;
            }
        }
        return true;
    }

    /**
     * @dev Internal function to convert a string to a uint256.
     * @param s The string to convert.
     * @return The converted uint256 value.
     */
    function stringToUint(string memory s) internal pure returns (uint256) {
        bytes memory b = bytes(s);
        uint256 result = 0;
        for (uint256 i = 0; i < b.length; i++) {
            require(b[i] >= 0x30 && b[i] <= 0x39, "Invalid character in string");
            result = result * 10 + (uint256(uint8(b[i])) - 48);
        }
        return result;
    }

    /**
     * @dev Function to estimate the reward for a given bet amount.
     * @param betAmount The bet amount.
     * @return The estimated reward.
     */
    function estimateReward(uint256 betAmount) public view returns (uint256) {
        // We generate a number between 1 and 10, inclusive. So the win chance is 1 of 10.
        // The reward multiplier is 10 minus the house fee percentage F.
        // So the reward is 10B - F, where B is a bet amount.
        return (10 * betAmount * (100 - houseFeePercentage)) / 100;
    }

    /**
     * @dev Function to check the status of the answer for a given prompt ID.
     * @param promptId The ID of the prompt.
     */
    function checkAnswerStatus(uint64 promptId) public view returns (string memory answer, bool exists) {
        try aiOracle.getAnswer(promptId) returns (string memory _answer) {
            return (_answer, true);
        } catch {
            return ("", false);
        }
    }

    /**
     * @dev Function to get the game information.
     * @return The game information.
     */
    function getGameInfo() external view returns (GameInfo memory) {
        return GameInfo({
            houseSupply: address(this).balance,
            houseActiveBalance: activeBalance(),
            minBetAmount: minBetAmount,
            maxBetAmount: maxBetAmount(),
            maxBetAmountPercentage: maxBetAmountPercentage
        });
    }
}